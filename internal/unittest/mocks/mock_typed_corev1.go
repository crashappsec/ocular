// Copyright (C) 2025 Crash Override, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the FSF, either version 3 of the License, or (at your option) any later version.
// See the LICENSE file in the root of this repository for full license text or
// visit: <https://www.gnu.org/licenses/gpl-3.0.html>.

// Code generated by MockGen. DO NOT EDIT.
// Source: k8s.io/client-go/kubernetes/typed/core/v1 (interfaces: SecretInterface,ConfigMapInterface,ServiceInterface)
//
// Generated by this command:
//
//	mockgen -destination mock_typed_corev1.go -package=mocks -typed k8s.io/client-go/kubernetes/typed/core/v1 SecretInterface,ConfigMapInterface,ServiceInterface
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
	v1 "k8s.io/api/core/v1"
	v10 "k8s.io/apimachinery/pkg/apis/meta/v1"
	types "k8s.io/apimachinery/pkg/types"
	watch "k8s.io/apimachinery/pkg/watch"
	v11 "k8s.io/client-go/applyconfigurations/core/v1"
	rest "k8s.io/client-go/rest"
)

// MockSecretInterface is a mock of SecretInterface interface.
type MockSecretInterface struct {
	ctrl     *gomock.Controller
	recorder *MockSecretInterfaceMockRecorder
	isgomock struct{}
}

// MockSecretInterfaceMockRecorder is the mock recorder for MockSecretInterface.
type MockSecretInterfaceMockRecorder struct {
	mock *MockSecretInterface
}

// NewMockSecretInterface creates a new mock instance.
func NewMockSecretInterface(ctrl *gomock.Controller) *MockSecretInterface {
	mock := &MockSecretInterface{ctrl: ctrl}
	mock.recorder = &MockSecretInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSecretInterface) EXPECT() *MockSecretInterfaceMockRecorder {
	return m.recorder
}

// Apply mocks base method.
func (m *MockSecretInterface) Apply(ctx context.Context, secret *v11.SecretApplyConfiguration, opts v10.ApplyOptions) (*v1.Secret, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Apply", ctx, secret, opts)
	ret0, _ := ret[0].(*v1.Secret)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Apply indicates an expected call of Apply.
func (mr *MockSecretInterfaceMockRecorder) Apply(ctx, secret, opts any) *MockSecretInterfaceApplyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockSecretInterface)(nil).Apply), ctx, secret, opts)
	return &MockSecretInterfaceApplyCall{Call: call}
}

// MockSecretInterfaceApplyCall wrap *gomock.Call
type MockSecretInterfaceApplyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSecretInterfaceApplyCall) Return(result *v1.Secret, err error) *MockSecretInterfaceApplyCall {
	c.Call = c.Call.Return(result, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSecretInterfaceApplyCall) Do(f func(context.Context, *v11.SecretApplyConfiguration, v10.ApplyOptions) (*v1.Secret, error)) *MockSecretInterfaceApplyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSecretInterfaceApplyCall) DoAndReturn(f func(context.Context, *v11.SecretApplyConfiguration, v10.ApplyOptions) (*v1.Secret, error)) *MockSecretInterfaceApplyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Create mocks base method.
func (m *MockSecretInterface) Create(ctx context.Context, secret *v1.Secret, opts v10.CreateOptions) (*v1.Secret, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, secret, opts)
	ret0, _ := ret[0].(*v1.Secret)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Create indicates an expected call of Create.
func (mr *MockSecretInterfaceMockRecorder) Create(ctx, secret, opts any) *MockSecretInterfaceCreateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockSecretInterface)(nil).Create), ctx, secret, opts)
	return &MockSecretInterfaceCreateCall{Call: call}
}

// MockSecretInterfaceCreateCall wrap *gomock.Call
type MockSecretInterfaceCreateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSecretInterfaceCreateCall) Return(arg0 *v1.Secret, arg1 error) *MockSecretInterfaceCreateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSecretInterfaceCreateCall) Do(f func(context.Context, *v1.Secret, v10.CreateOptions) (*v1.Secret, error)) *MockSecretInterfaceCreateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSecretInterfaceCreateCall) DoAndReturn(f func(context.Context, *v1.Secret, v10.CreateOptions) (*v1.Secret, error)) *MockSecretInterfaceCreateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Delete mocks base method.
func (m *MockSecretInterface) Delete(ctx context.Context, name string, opts v10.DeleteOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, name, opts)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockSecretInterfaceMockRecorder) Delete(ctx, name, opts any) *MockSecretInterfaceDeleteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockSecretInterface)(nil).Delete), ctx, name, opts)
	return &MockSecretInterfaceDeleteCall{Call: call}
}

// MockSecretInterfaceDeleteCall wrap *gomock.Call
type MockSecretInterfaceDeleteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSecretInterfaceDeleteCall) Return(arg0 error) *MockSecretInterfaceDeleteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSecretInterfaceDeleteCall) Do(f func(context.Context, string, v10.DeleteOptions) error) *MockSecretInterfaceDeleteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSecretInterfaceDeleteCall) DoAndReturn(f func(context.Context, string, v10.DeleteOptions) error) *MockSecretInterfaceDeleteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteCollection mocks base method.
func (m *MockSecretInterface) DeleteCollection(ctx context.Context, opts v10.DeleteOptions, listOpts v10.ListOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteCollection", ctx, opts, listOpts)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteCollection indicates an expected call of DeleteCollection.
func (mr *MockSecretInterfaceMockRecorder) DeleteCollection(ctx, opts, listOpts any) *MockSecretInterfaceDeleteCollectionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteCollection", reflect.TypeOf((*MockSecretInterface)(nil).DeleteCollection), ctx, opts, listOpts)
	return &MockSecretInterfaceDeleteCollectionCall{Call: call}
}

// MockSecretInterfaceDeleteCollectionCall wrap *gomock.Call
type MockSecretInterfaceDeleteCollectionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSecretInterfaceDeleteCollectionCall) Return(arg0 error) *MockSecretInterfaceDeleteCollectionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSecretInterfaceDeleteCollectionCall) Do(f func(context.Context, v10.DeleteOptions, v10.ListOptions) error) *MockSecretInterfaceDeleteCollectionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSecretInterfaceDeleteCollectionCall) DoAndReturn(f func(context.Context, v10.DeleteOptions, v10.ListOptions) error) *MockSecretInterfaceDeleteCollectionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Get mocks base method.
func (m *MockSecretInterface) Get(ctx context.Context, name string, opts v10.GetOptions) (*v1.Secret, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, name, opts)
	ret0, _ := ret[0].(*v1.Secret)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockSecretInterfaceMockRecorder) Get(ctx, name, opts any) *MockSecretInterfaceGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockSecretInterface)(nil).Get), ctx, name, opts)
	return &MockSecretInterfaceGetCall{Call: call}
}

// MockSecretInterfaceGetCall wrap *gomock.Call
type MockSecretInterfaceGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSecretInterfaceGetCall) Return(arg0 *v1.Secret, arg1 error) *MockSecretInterfaceGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSecretInterfaceGetCall) Do(f func(context.Context, string, v10.GetOptions) (*v1.Secret, error)) *MockSecretInterfaceGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSecretInterfaceGetCall) DoAndReturn(f func(context.Context, string, v10.GetOptions) (*v1.Secret, error)) *MockSecretInterfaceGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// List mocks base method.
func (m *MockSecretInterface) List(ctx context.Context, opts v10.ListOptions) (*v1.SecretList, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List", ctx, opts)
	ret0, _ := ret[0].(*v1.SecretList)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// List indicates an expected call of List.
func (mr *MockSecretInterfaceMockRecorder) List(ctx, opts any) *MockSecretInterfaceListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockSecretInterface)(nil).List), ctx, opts)
	return &MockSecretInterfaceListCall{Call: call}
}

// MockSecretInterfaceListCall wrap *gomock.Call
type MockSecretInterfaceListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSecretInterfaceListCall) Return(arg0 *v1.SecretList, arg1 error) *MockSecretInterfaceListCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSecretInterfaceListCall) Do(f func(context.Context, v10.ListOptions) (*v1.SecretList, error)) *MockSecretInterfaceListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSecretInterfaceListCall) DoAndReturn(f func(context.Context, v10.ListOptions) (*v1.SecretList, error)) *MockSecretInterfaceListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Patch mocks base method.
func (m *MockSecretInterface) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v10.PatchOptions, subresources ...string) (*v1.Secret, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, name, pt, data, opts}
	for _, a := range subresources {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Patch", varargs...)
	ret0, _ := ret[0].(*v1.Secret)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Patch indicates an expected call of Patch.
func (mr *MockSecretInterfaceMockRecorder) Patch(ctx, name, pt, data, opts any, subresources ...any) *MockSecretInterfacePatchCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, name, pt, data, opts}, subresources...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Patch", reflect.TypeOf((*MockSecretInterface)(nil).Patch), varargs...)
	return &MockSecretInterfacePatchCall{Call: call}
}

// MockSecretInterfacePatchCall wrap *gomock.Call
type MockSecretInterfacePatchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSecretInterfacePatchCall) Return(result *v1.Secret, err error) *MockSecretInterfacePatchCall {
	c.Call = c.Call.Return(result, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSecretInterfacePatchCall) Do(f func(context.Context, string, types.PatchType, []byte, v10.PatchOptions, ...string) (*v1.Secret, error)) *MockSecretInterfacePatchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSecretInterfacePatchCall) DoAndReturn(f func(context.Context, string, types.PatchType, []byte, v10.PatchOptions, ...string) (*v1.Secret, error)) *MockSecretInterfacePatchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Update mocks base method.
func (m *MockSecretInterface) Update(ctx context.Context, secret *v1.Secret, opts v10.UpdateOptions) (*v1.Secret, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, secret, opts)
	ret0, _ := ret[0].(*v1.Secret)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockSecretInterfaceMockRecorder) Update(ctx, secret, opts any) *MockSecretInterfaceUpdateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockSecretInterface)(nil).Update), ctx, secret, opts)
	return &MockSecretInterfaceUpdateCall{Call: call}
}

// MockSecretInterfaceUpdateCall wrap *gomock.Call
type MockSecretInterfaceUpdateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSecretInterfaceUpdateCall) Return(arg0 *v1.Secret, arg1 error) *MockSecretInterfaceUpdateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSecretInterfaceUpdateCall) Do(f func(context.Context, *v1.Secret, v10.UpdateOptions) (*v1.Secret, error)) *MockSecretInterfaceUpdateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSecretInterfaceUpdateCall) DoAndReturn(f func(context.Context, *v1.Secret, v10.UpdateOptions) (*v1.Secret, error)) *MockSecretInterfaceUpdateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Watch mocks base method.
func (m *MockSecretInterface) Watch(ctx context.Context, opts v10.ListOptions) (watch.Interface, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Watch", ctx, opts)
	ret0, _ := ret[0].(watch.Interface)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Watch indicates an expected call of Watch.
func (mr *MockSecretInterfaceMockRecorder) Watch(ctx, opts any) *MockSecretInterfaceWatchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Watch", reflect.TypeOf((*MockSecretInterface)(nil).Watch), ctx, opts)
	return &MockSecretInterfaceWatchCall{Call: call}
}

// MockSecretInterfaceWatchCall wrap *gomock.Call
type MockSecretInterfaceWatchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSecretInterfaceWatchCall) Return(arg0 watch.Interface, arg1 error) *MockSecretInterfaceWatchCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSecretInterfaceWatchCall) Do(f func(context.Context, v10.ListOptions) (watch.Interface, error)) *MockSecretInterfaceWatchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSecretInterfaceWatchCall) DoAndReturn(f func(context.Context, v10.ListOptions) (watch.Interface, error)) *MockSecretInterfaceWatchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockConfigMapInterface is a mock of ConfigMapInterface interface.
type MockConfigMapInterface struct {
	ctrl     *gomock.Controller
	recorder *MockConfigMapInterfaceMockRecorder
	isgomock struct{}
}

// MockConfigMapInterfaceMockRecorder is the mock recorder for MockConfigMapInterface.
type MockConfigMapInterfaceMockRecorder struct {
	mock *MockConfigMapInterface
}

// NewMockConfigMapInterface creates a new mock instance.
func NewMockConfigMapInterface(ctrl *gomock.Controller) *MockConfigMapInterface {
	mock := &MockConfigMapInterface{ctrl: ctrl}
	mock.recorder = &MockConfigMapInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConfigMapInterface) EXPECT() *MockConfigMapInterfaceMockRecorder {
	return m.recorder
}

// Apply mocks base method.
func (m *MockConfigMapInterface) Apply(ctx context.Context, configMap *v11.ConfigMapApplyConfiguration, opts v10.ApplyOptions) (*v1.ConfigMap, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Apply", ctx, configMap, opts)
	ret0, _ := ret[0].(*v1.ConfigMap)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Apply indicates an expected call of Apply.
func (mr *MockConfigMapInterfaceMockRecorder) Apply(ctx, configMap, opts any) *MockConfigMapInterfaceApplyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockConfigMapInterface)(nil).Apply), ctx, configMap, opts)
	return &MockConfigMapInterfaceApplyCall{Call: call}
}

// MockConfigMapInterfaceApplyCall wrap *gomock.Call
type MockConfigMapInterfaceApplyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConfigMapInterfaceApplyCall) Return(result *v1.ConfigMap, err error) *MockConfigMapInterfaceApplyCall {
	c.Call = c.Call.Return(result, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConfigMapInterfaceApplyCall) Do(f func(context.Context, *v11.ConfigMapApplyConfiguration, v10.ApplyOptions) (*v1.ConfigMap, error)) *MockConfigMapInterfaceApplyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConfigMapInterfaceApplyCall) DoAndReturn(f func(context.Context, *v11.ConfigMapApplyConfiguration, v10.ApplyOptions) (*v1.ConfigMap, error)) *MockConfigMapInterfaceApplyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Create mocks base method.
func (m *MockConfigMapInterface) Create(ctx context.Context, configMap *v1.ConfigMap, opts v10.CreateOptions) (*v1.ConfigMap, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, configMap, opts)
	ret0, _ := ret[0].(*v1.ConfigMap)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Create indicates an expected call of Create.
func (mr *MockConfigMapInterfaceMockRecorder) Create(ctx, configMap, opts any) *MockConfigMapInterfaceCreateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockConfigMapInterface)(nil).Create), ctx, configMap, opts)
	return &MockConfigMapInterfaceCreateCall{Call: call}
}

// MockConfigMapInterfaceCreateCall wrap *gomock.Call
type MockConfigMapInterfaceCreateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConfigMapInterfaceCreateCall) Return(arg0 *v1.ConfigMap, arg1 error) *MockConfigMapInterfaceCreateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConfigMapInterfaceCreateCall) Do(f func(context.Context, *v1.ConfigMap, v10.CreateOptions) (*v1.ConfigMap, error)) *MockConfigMapInterfaceCreateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConfigMapInterfaceCreateCall) DoAndReturn(f func(context.Context, *v1.ConfigMap, v10.CreateOptions) (*v1.ConfigMap, error)) *MockConfigMapInterfaceCreateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Delete mocks base method.
func (m *MockConfigMapInterface) Delete(ctx context.Context, name string, opts v10.DeleteOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, name, opts)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockConfigMapInterfaceMockRecorder) Delete(ctx, name, opts any) *MockConfigMapInterfaceDeleteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockConfigMapInterface)(nil).Delete), ctx, name, opts)
	return &MockConfigMapInterfaceDeleteCall{Call: call}
}

// MockConfigMapInterfaceDeleteCall wrap *gomock.Call
type MockConfigMapInterfaceDeleteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConfigMapInterfaceDeleteCall) Return(arg0 error) *MockConfigMapInterfaceDeleteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConfigMapInterfaceDeleteCall) Do(f func(context.Context, string, v10.DeleteOptions) error) *MockConfigMapInterfaceDeleteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConfigMapInterfaceDeleteCall) DoAndReturn(f func(context.Context, string, v10.DeleteOptions) error) *MockConfigMapInterfaceDeleteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteCollection mocks base method.
func (m *MockConfigMapInterface) DeleteCollection(ctx context.Context, opts v10.DeleteOptions, listOpts v10.ListOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteCollection", ctx, opts, listOpts)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteCollection indicates an expected call of DeleteCollection.
func (mr *MockConfigMapInterfaceMockRecorder) DeleteCollection(ctx, opts, listOpts any) *MockConfigMapInterfaceDeleteCollectionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteCollection", reflect.TypeOf((*MockConfigMapInterface)(nil).DeleteCollection), ctx, opts, listOpts)
	return &MockConfigMapInterfaceDeleteCollectionCall{Call: call}
}

// MockConfigMapInterfaceDeleteCollectionCall wrap *gomock.Call
type MockConfigMapInterfaceDeleteCollectionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConfigMapInterfaceDeleteCollectionCall) Return(arg0 error) *MockConfigMapInterfaceDeleteCollectionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConfigMapInterfaceDeleteCollectionCall) Do(f func(context.Context, v10.DeleteOptions, v10.ListOptions) error) *MockConfigMapInterfaceDeleteCollectionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConfigMapInterfaceDeleteCollectionCall) DoAndReturn(f func(context.Context, v10.DeleteOptions, v10.ListOptions) error) *MockConfigMapInterfaceDeleteCollectionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Get mocks base method.
func (m *MockConfigMapInterface) Get(ctx context.Context, name string, opts v10.GetOptions) (*v1.ConfigMap, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, name, opts)
	ret0, _ := ret[0].(*v1.ConfigMap)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockConfigMapInterfaceMockRecorder) Get(ctx, name, opts any) *MockConfigMapInterfaceGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockConfigMapInterface)(nil).Get), ctx, name, opts)
	return &MockConfigMapInterfaceGetCall{Call: call}
}

// MockConfigMapInterfaceGetCall wrap *gomock.Call
type MockConfigMapInterfaceGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConfigMapInterfaceGetCall) Return(arg0 *v1.ConfigMap, arg1 error) *MockConfigMapInterfaceGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConfigMapInterfaceGetCall) Do(f func(context.Context, string, v10.GetOptions) (*v1.ConfigMap, error)) *MockConfigMapInterfaceGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConfigMapInterfaceGetCall) DoAndReturn(f func(context.Context, string, v10.GetOptions) (*v1.ConfigMap, error)) *MockConfigMapInterfaceGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// List mocks base method.
func (m *MockConfigMapInterface) List(ctx context.Context, opts v10.ListOptions) (*v1.ConfigMapList, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List", ctx, opts)
	ret0, _ := ret[0].(*v1.ConfigMapList)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// List indicates an expected call of List.
func (mr *MockConfigMapInterfaceMockRecorder) List(ctx, opts any) *MockConfigMapInterfaceListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockConfigMapInterface)(nil).List), ctx, opts)
	return &MockConfigMapInterfaceListCall{Call: call}
}

// MockConfigMapInterfaceListCall wrap *gomock.Call
type MockConfigMapInterfaceListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConfigMapInterfaceListCall) Return(arg0 *v1.ConfigMapList, arg1 error) *MockConfigMapInterfaceListCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConfigMapInterfaceListCall) Do(f func(context.Context, v10.ListOptions) (*v1.ConfigMapList, error)) *MockConfigMapInterfaceListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConfigMapInterfaceListCall) DoAndReturn(f func(context.Context, v10.ListOptions) (*v1.ConfigMapList, error)) *MockConfigMapInterfaceListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Patch mocks base method.
func (m *MockConfigMapInterface) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v10.PatchOptions, subresources ...string) (*v1.ConfigMap, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, name, pt, data, opts}
	for _, a := range subresources {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Patch", varargs...)
	ret0, _ := ret[0].(*v1.ConfigMap)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Patch indicates an expected call of Patch.
func (mr *MockConfigMapInterfaceMockRecorder) Patch(ctx, name, pt, data, opts any, subresources ...any) *MockConfigMapInterfacePatchCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, name, pt, data, opts}, subresources...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Patch", reflect.TypeOf((*MockConfigMapInterface)(nil).Patch), varargs...)
	return &MockConfigMapInterfacePatchCall{Call: call}
}

// MockConfigMapInterfacePatchCall wrap *gomock.Call
type MockConfigMapInterfacePatchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConfigMapInterfacePatchCall) Return(result *v1.ConfigMap, err error) *MockConfigMapInterfacePatchCall {
	c.Call = c.Call.Return(result, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConfigMapInterfacePatchCall) Do(f func(context.Context, string, types.PatchType, []byte, v10.PatchOptions, ...string) (*v1.ConfigMap, error)) *MockConfigMapInterfacePatchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConfigMapInterfacePatchCall) DoAndReturn(f func(context.Context, string, types.PatchType, []byte, v10.PatchOptions, ...string) (*v1.ConfigMap, error)) *MockConfigMapInterfacePatchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Update mocks base method.
func (m *MockConfigMapInterface) Update(ctx context.Context, configMap *v1.ConfigMap, opts v10.UpdateOptions) (*v1.ConfigMap, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, configMap, opts)
	ret0, _ := ret[0].(*v1.ConfigMap)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockConfigMapInterfaceMockRecorder) Update(ctx, configMap, opts any) *MockConfigMapInterfaceUpdateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockConfigMapInterface)(nil).Update), ctx, configMap, opts)
	return &MockConfigMapInterfaceUpdateCall{Call: call}
}

// MockConfigMapInterfaceUpdateCall wrap *gomock.Call
type MockConfigMapInterfaceUpdateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConfigMapInterfaceUpdateCall) Return(arg0 *v1.ConfigMap, arg1 error) *MockConfigMapInterfaceUpdateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConfigMapInterfaceUpdateCall) Do(f func(context.Context, *v1.ConfigMap, v10.UpdateOptions) (*v1.ConfigMap, error)) *MockConfigMapInterfaceUpdateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConfigMapInterfaceUpdateCall) DoAndReturn(f func(context.Context, *v1.ConfigMap, v10.UpdateOptions) (*v1.ConfigMap, error)) *MockConfigMapInterfaceUpdateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Watch mocks base method.
func (m *MockConfigMapInterface) Watch(ctx context.Context, opts v10.ListOptions) (watch.Interface, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Watch", ctx, opts)
	ret0, _ := ret[0].(watch.Interface)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Watch indicates an expected call of Watch.
func (mr *MockConfigMapInterfaceMockRecorder) Watch(ctx, opts any) *MockConfigMapInterfaceWatchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Watch", reflect.TypeOf((*MockConfigMapInterface)(nil).Watch), ctx, opts)
	return &MockConfigMapInterfaceWatchCall{Call: call}
}

// MockConfigMapInterfaceWatchCall wrap *gomock.Call
type MockConfigMapInterfaceWatchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockConfigMapInterfaceWatchCall) Return(arg0 watch.Interface, arg1 error) *MockConfigMapInterfaceWatchCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockConfigMapInterfaceWatchCall) Do(f func(context.Context, v10.ListOptions) (watch.Interface, error)) *MockConfigMapInterfaceWatchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockConfigMapInterfaceWatchCall) DoAndReturn(f func(context.Context, v10.ListOptions) (watch.Interface, error)) *MockConfigMapInterfaceWatchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockServiceInterface is a mock of ServiceInterface interface.
type MockServiceInterface struct {
	ctrl     *gomock.Controller
	recorder *MockServiceInterfaceMockRecorder
	isgomock struct{}
}

// MockServiceInterfaceMockRecorder is the mock recorder for MockServiceInterface.
type MockServiceInterfaceMockRecorder struct {
	mock *MockServiceInterface
}

// NewMockServiceInterface creates a new mock instance.
func NewMockServiceInterface(ctrl *gomock.Controller) *MockServiceInterface {
	mock := &MockServiceInterface{ctrl: ctrl}
	mock.recorder = &MockServiceInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockServiceInterface) EXPECT() *MockServiceInterfaceMockRecorder {
	return m.recorder
}

// Apply mocks base method.
func (m *MockServiceInterface) Apply(ctx context.Context, service *v11.ServiceApplyConfiguration, opts v10.ApplyOptions) (*v1.Service, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Apply", ctx, service, opts)
	ret0, _ := ret[0].(*v1.Service)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Apply indicates an expected call of Apply.
func (mr *MockServiceInterfaceMockRecorder) Apply(ctx, service, opts any) *MockServiceInterfaceApplyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockServiceInterface)(nil).Apply), ctx, service, opts)
	return &MockServiceInterfaceApplyCall{Call: call}
}

// MockServiceInterfaceApplyCall wrap *gomock.Call
type MockServiceInterfaceApplyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceInterfaceApplyCall) Return(result *v1.Service, err error) *MockServiceInterfaceApplyCall {
	c.Call = c.Call.Return(result, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceInterfaceApplyCall) Do(f func(context.Context, *v11.ServiceApplyConfiguration, v10.ApplyOptions) (*v1.Service, error)) *MockServiceInterfaceApplyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceInterfaceApplyCall) DoAndReturn(f func(context.Context, *v11.ServiceApplyConfiguration, v10.ApplyOptions) (*v1.Service, error)) *MockServiceInterfaceApplyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ApplyStatus mocks base method.
func (m *MockServiceInterface) ApplyStatus(ctx context.Context, service *v11.ServiceApplyConfiguration, opts v10.ApplyOptions) (*v1.Service, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplyStatus", ctx, service, opts)
	ret0, _ := ret[0].(*v1.Service)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ApplyStatus indicates an expected call of ApplyStatus.
func (mr *MockServiceInterfaceMockRecorder) ApplyStatus(ctx, service, opts any) *MockServiceInterfaceApplyStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplyStatus", reflect.TypeOf((*MockServiceInterface)(nil).ApplyStatus), ctx, service, opts)
	return &MockServiceInterfaceApplyStatusCall{Call: call}
}

// MockServiceInterfaceApplyStatusCall wrap *gomock.Call
type MockServiceInterfaceApplyStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceInterfaceApplyStatusCall) Return(result *v1.Service, err error) *MockServiceInterfaceApplyStatusCall {
	c.Call = c.Call.Return(result, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceInterfaceApplyStatusCall) Do(f func(context.Context, *v11.ServiceApplyConfiguration, v10.ApplyOptions) (*v1.Service, error)) *MockServiceInterfaceApplyStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceInterfaceApplyStatusCall) DoAndReturn(f func(context.Context, *v11.ServiceApplyConfiguration, v10.ApplyOptions) (*v1.Service, error)) *MockServiceInterfaceApplyStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Create mocks base method.
func (m *MockServiceInterface) Create(ctx context.Context, service *v1.Service, opts v10.CreateOptions) (*v1.Service, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, service, opts)
	ret0, _ := ret[0].(*v1.Service)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Create indicates an expected call of Create.
func (mr *MockServiceInterfaceMockRecorder) Create(ctx, service, opts any) *MockServiceInterfaceCreateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockServiceInterface)(nil).Create), ctx, service, opts)
	return &MockServiceInterfaceCreateCall{Call: call}
}

// MockServiceInterfaceCreateCall wrap *gomock.Call
type MockServiceInterfaceCreateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceInterfaceCreateCall) Return(arg0 *v1.Service, arg1 error) *MockServiceInterfaceCreateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceInterfaceCreateCall) Do(f func(context.Context, *v1.Service, v10.CreateOptions) (*v1.Service, error)) *MockServiceInterfaceCreateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceInterfaceCreateCall) DoAndReturn(f func(context.Context, *v1.Service, v10.CreateOptions) (*v1.Service, error)) *MockServiceInterfaceCreateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Delete mocks base method.
func (m *MockServiceInterface) Delete(ctx context.Context, name string, opts v10.DeleteOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, name, opts)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockServiceInterfaceMockRecorder) Delete(ctx, name, opts any) *MockServiceInterfaceDeleteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockServiceInterface)(nil).Delete), ctx, name, opts)
	return &MockServiceInterfaceDeleteCall{Call: call}
}

// MockServiceInterfaceDeleteCall wrap *gomock.Call
type MockServiceInterfaceDeleteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceInterfaceDeleteCall) Return(arg0 error) *MockServiceInterfaceDeleteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceInterfaceDeleteCall) Do(f func(context.Context, string, v10.DeleteOptions) error) *MockServiceInterfaceDeleteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceInterfaceDeleteCall) DoAndReturn(f func(context.Context, string, v10.DeleteOptions) error) *MockServiceInterfaceDeleteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Get mocks base method.
func (m *MockServiceInterface) Get(ctx context.Context, name string, opts v10.GetOptions) (*v1.Service, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, name, opts)
	ret0, _ := ret[0].(*v1.Service)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockServiceInterfaceMockRecorder) Get(ctx, name, opts any) *MockServiceInterfaceGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockServiceInterface)(nil).Get), ctx, name, opts)
	return &MockServiceInterfaceGetCall{Call: call}
}

// MockServiceInterfaceGetCall wrap *gomock.Call
type MockServiceInterfaceGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceInterfaceGetCall) Return(arg0 *v1.Service, arg1 error) *MockServiceInterfaceGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceInterfaceGetCall) Do(f func(context.Context, string, v10.GetOptions) (*v1.Service, error)) *MockServiceInterfaceGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceInterfaceGetCall) DoAndReturn(f func(context.Context, string, v10.GetOptions) (*v1.Service, error)) *MockServiceInterfaceGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// List mocks base method.
func (m *MockServiceInterface) List(ctx context.Context, opts v10.ListOptions) (*v1.ServiceList, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List", ctx, opts)
	ret0, _ := ret[0].(*v1.ServiceList)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// List indicates an expected call of List.
func (mr *MockServiceInterfaceMockRecorder) List(ctx, opts any) *MockServiceInterfaceListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockServiceInterface)(nil).List), ctx, opts)
	return &MockServiceInterfaceListCall{Call: call}
}

// MockServiceInterfaceListCall wrap *gomock.Call
type MockServiceInterfaceListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceInterfaceListCall) Return(arg0 *v1.ServiceList, arg1 error) *MockServiceInterfaceListCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceInterfaceListCall) Do(f func(context.Context, v10.ListOptions) (*v1.ServiceList, error)) *MockServiceInterfaceListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceInterfaceListCall) DoAndReturn(f func(context.Context, v10.ListOptions) (*v1.ServiceList, error)) *MockServiceInterfaceListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Patch mocks base method.
func (m *MockServiceInterface) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v10.PatchOptions, subresources ...string) (*v1.Service, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, name, pt, data, opts}
	for _, a := range subresources {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Patch", varargs...)
	ret0, _ := ret[0].(*v1.Service)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Patch indicates an expected call of Patch.
func (mr *MockServiceInterfaceMockRecorder) Patch(ctx, name, pt, data, opts any, subresources ...any) *MockServiceInterfacePatchCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, name, pt, data, opts}, subresources...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Patch", reflect.TypeOf((*MockServiceInterface)(nil).Patch), varargs...)
	return &MockServiceInterfacePatchCall{Call: call}
}

// MockServiceInterfacePatchCall wrap *gomock.Call
type MockServiceInterfacePatchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceInterfacePatchCall) Return(result *v1.Service, err error) *MockServiceInterfacePatchCall {
	c.Call = c.Call.Return(result, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceInterfacePatchCall) Do(f func(context.Context, string, types.PatchType, []byte, v10.PatchOptions, ...string) (*v1.Service, error)) *MockServiceInterfacePatchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceInterfacePatchCall) DoAndReturn(f func(context.Context, string, types.PatchType, []byte, v10.PatchOptions, ...string) (*v1.Service, error)) *MockServiceInterfacePatchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ProxyGet mocks base method.
func (m *MockServiceInterface) ProxyGet(scheme, name, port, path string, params map[string]string) rest.ResponseWrapper {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ProxyGet", scheme, name, port, path, params)
	ret0, _ := ret[0].(rest.ResponseWrapper)
	return ret0
}

// ProxyGet indicates an expected call of ProxyGet.
func (mr *MockServiceInterfaceMockRecorder) ProxyGet(scheme, name, port, path, params any) *MockServiceInterfaceProxyGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProxyGet", reflect.TypeOf((*MockServiceInterface)(nil).ProxyGet), scheme, name, port, path, params)
	return &MockServiceInterfaceProxyGetCall{Call: call}
}

// MockServiceInterfaceProxyGetCall wrap *gomock.Call
type MockServiceInterfaceProxyGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceInterfaceProxyGetCall) Return(arg0 rest.ResponseWrapper) *MockServiceInterfaceProxyGetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceInterfaceProxyGetCall) Do(f func(string, string, string, string, map[string]string) rest.ResponseWrapper) *MockServiceInterfaceProxyGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceInterfaceProxyGetCall) DoAndReturn(f func(string, string, string, string, map[string]string) rest.ResponseWrapper) *MockServiceInterfaceProxyGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Update mocks base method.
func (m *MockServiceInterface) Update(ctx context.Context, service *v1.Service, opts v10.UpdateOptions) (*v1.Service, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, service, opts)
	ret0, _ := ret[0].(*v1.Service)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockServiceInterfaceMockRecorder) Update(ctx, service, opts any) *MockServiceInterfaceUpdateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockServiceInterface)(nil).Update), ctx, service, opts)
	return &MockServiceInterfaceUpdateCall{Call: call}
}

// MockServiceInterfaceUpdateCall wrap *gomock.Call
type MockServiceInterfaceUpdateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceInterfaceUpdateCall) Return(arg0 *v1.Service, arg1 error) *MockServiceInterfaceUpdateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceInterfaceUpdateCall) Do(f func(context.Context, *v1.Service, v10.UpdateOptions) (*v1.Service, error)) *MockServiceInterfaceUpdateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceInterfaceUpdateCall) DoAndReturn(f func(context.Context, *v1.Service, v10.UpdateOptions) (*v1.Service, error)) *MockServiceInterfaceUpdateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateStatus mocks base method.
func (m *MockServiceInterface) UpdateStatus(ctx context.Context, service *v1.Service, opts v10.UpdateOptions) (*v1.Service, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateStatus", ctx, service, opts)
	ret0, _ := ret[0].(*v1.Service)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateStatus indicates an expected call of UpdateStatus.
func (mr *MockServiceInterfaceMockRecorder) UpdateStatus(ctx, service, opts any) *MockServiceInterfaceUpdateStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateStatus", reflect.TypeOf((*MockServiceInterface)(nil).UpdateStatus), ctx, service, opts)
	return &MockServiceInterfaceUpdateStatusCall{Call: call}
}

// MockServiceInterfaceUpdateStatusCall wrap *gomock.Call
type MockServiceInterfaceUpdateStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceInterfaceUpdateStatusCall) Return(arg0 *v1.Service, arg1 error) *MockServiceInterfaceUpdateStatusCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceInterfaceUpdateStatusCall) Do(f func(context.Context, *v1.Service, v10.UpdateOptions) (*v1.Service, error)) *MockServiceInterfaceUpdateStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceInterfaceUpdateStatusCall) DoAndReturn(f func(context.Context, *v1.Service, v10.UpdateOptions) (*v1.Service, error)) *MockServiceInterfaceUpdateStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Watch mocks base method.
func (m *MockServiceInterface) Watch(ctx context.Context, opts v10.ListOptions) (watch.Interface, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Watch", ctx, opts)
	ret0, _ := ret[0].(watch.Interface)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Watch indicates an expected call of Watch.
func (mr *MockServiceInterfaceMockRecorder) Watch(ctx, opts any) *MockServiceInterfaceWatchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Watch", reflect.TypeOf((*MockServiceInterface)(nil).Watch), ctx, opts)
	return &MockServiceInterfaceWatchCall{Call: call}
}

// MockServiceInterfaceWatchCall wrap *gomock.Call
type MockServiceInterfaceWatchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceInterfaceWatchCall) Return(arg0 watch.Interface, arg1 error) *MockServiceInterfaceWatchCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceInterfaceWatchCall) Do(f func(context.Context, v10.ListOptions) (watch.Interface, error)) *MockServiceInterfaceWatchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceInterfaceWatchCall) DoAndReturn(f func(context.Context, v10.ListOptions) (watch.Interface, error)) *MockServiceInterfaceWatchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
